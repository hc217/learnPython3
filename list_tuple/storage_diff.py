# 前面说了，列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。
# 这样的差异，势必会影响两者存储方式。我们可以来看下面的例子

l = [1, 2, 3]
print(l.__sizeof__())  # 打印列表所占字节数
# 64
tup = (1, 2, 3)
print(tup.__sizeof__())  # 打印元组所占字节数
# 48

# 事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。
# 另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。

l = []
print(l.__sizeof__())   # 空列表的存储空间为40字节
# 40
l.append(1)
print(l.__sizeof__())
# 72  加入了元素1之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4
l.append(2)
print(l.__sizeof__())
# 72  由于之前分配了空间，所以加入元素2，列表空间不变
l.append(3)
print(l.__sizeof__())
# 72  同上
l.append(4)
print(l.__sizeof__())
# 72  同上
l.append(5)
print(l.__sizeof__())
#104  加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间

# 上面的例子，大概描述了列表空间分配的过程。
# 我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，
# Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。