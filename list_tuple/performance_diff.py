# 通过学习列表和元组存储方式的差异，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。
# 另外，Python 会在后台，对静态数据做一些资源缓存（resource caching）。
# 通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。
# 但是对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。
# 这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，
# 这样就能大大加快程序的运行速度。
# 下面的例子，是计算初始化一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度，要比列表快 5 倍。
from timeit import timeit

# python3 -m timeit 'x=(1,2,3,4,5,6)'
x='(1,2,3,4,5,6)'
print(timeit(x))
#20000000 loops, best of 5: 9.97 nsec per loop
# python3 -m timeit 'x=[1,2,3,4,5,6]'
y = '[1,2,3,4,5,6]'
print((timeit(y)))
# 5000000 loops, best of 5: 50.1 nsec per loop

# 但如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。

# python3 -m timeit -s 'x=[1,2,3,4,5,6]' 'y=x[3]'
# 10000000 loops, best of 5: 22.2 nsec per loop
# python3 -m timeit -s 'x=(1,2,3,4,5,6)' 'y=x[3]'
# 10000000 loops, best of 5: 21.9 nsec per loop